#' Process white gps data (i-gotU)
#'
#' This function loads .csv files generated by the i-gotU gps and generates .rds
#' files that have an associated geometry column so they can be used as sf
#' objects. The CRS associated with the generated files is epsg:4326.
#' Function will also calculate speed and course over ground (COG) and will
#' remove unnecessary columns.
#'
#' One advantage is that function can process all .csv files under a directory
#' or can do the process for single files.
#' Also a gear for the vessel may be specified if it is known.
#' @param dir Directory where the .csv files are.
#' @param input_file Input file, only needed if process_all is set to FALSE.
#' @param vessel_code CFR code of the vessel.
#' @param le_met4_value Metier DCF level 4 if known (optional).
#' @param le_met6_value Metier DCF level 6 if known (optional).
#' @param le_met7_value Target species, AL3 code if known (optional).
#' @param process_all Wheter to process all csv files or not, defaults to FALSE
#' @return Several procesed .rds, .csv and .gpkg files with the same base name as the
#' input and _formatted, _formatted_final and formatted_postgis appended to the
#' file name. Except for the one with the _postgis append, files are created
#' both in .rds and .csv format. File _final and _postgis have a geometry column,
#' but note that it will be loaded as a char column. If you need proper geometry
#' use the .gpkg file. The _postgis file geometry is compatible with postgis server.
#' @examples
#' # Process only one file
#' process_white_gps_data("/dir/path/to/files/", "filename.csv", "cfr_code", "3_letter_met4_code", "metier_6_code", "Target_species_AL3")
#' # Process all files in directory
#' process_white_gps_data("/dir/path/to/files/", "cfr_code", "3_letter_met4_code", proces_all = TRUE)
#' @export
process_white_gps_data <- function(dir, input_file = NULL, vessel_code, le_met4_value = NA, le_met6_value = NA, le_met7_value = NA, process_all = FALSE) {
  # Helper function to process a single file
  process_single_file <- function(file_path, vessel_code, le_met4_value, le_met6_value, le_met7_value) {
    # Extract the base name
    base_name <- tools::file_path_sans_ext(basename(file_path))
    csv_formateado <- file.path(dirname(file_path), paste0(base_name, "_formatted.csv"))
    rds_formateado <- file.path(dirname(file_path), paste0(base_name, "_formatted.rds"))
    final_csv <- file.path(dirname(file_path), paste0(base_name, "_formatted_final.csv"))
    final_rds <- file.path(dirname(file_path), paste0(base_name, "_formatted_final.rds"))
    final_gpkg <- file.path(dirname(file_path), paste0(base_name, "_formatted_final.gpkg"))
    postgis_csv <- file.path(dirname(file_path), paste0(base_name, "_formatted_postgis.csv"))

    # Load the input CSV file
    data <- readr::read_csv(file_path)

    # Write formatted CSV
    write.table(data,
                file = csv_formateado,
                sep = ";",
                dec = ".",
                row.names = FALSE,
                col.names = TRUE,
                quote = FALSE)

    # Read formatted CSV
    vessel_track_df <- readr::read_delim(csv_formateado, delim = ";")

    # Select and rename columns based on the presence of HDOP column
    if ("HDOP" %in% colnames(vessel_track_df)) {
      vessel_track_df <- vessel_track_df %>%
        dplyr::select(-`Altitude(m)`, -`Visible Satellites`, -`Satellites(CN>22)`, -HDOP, -`Distance(m)`) %>%
        dplyr::rename(
          SI_TIMESTAMP = Time,
          SI_LATI = Latitude,
          SI_LONG = Longitude,
          SI_SP = `Speed(km/h)`,
          SI_HE = Course
        )
    } else {
      vessel_track_df <- vessel_track_df %>%
        dplyr::select(-Altitude, -Type, -Essential, -Distance) %>%
        dplyr::mutate(SI_TIMESTAMP = as.POSIXct(paste(Date, Time), format = "%Y-%m-%d %H:%M:%S")) %>%
        dplyr::rename(
          SI_LATI = Latitude,
          SI_LONG = Longitude,
          SI_SP = Speed,
          SI_HE = Course
        )
    }

    # Process the data
    vessel_track_df <- vessel_track_df %>%
      dplyr::mutate(SI_TIMESTAMP = lubridate::ymd_hms(SI_TIMESTAMP, tz = "UTC"),
             SI_SP = SI_SP * 0.539957) %>%
      dplyr::group_by(floor_date(SI_TIMESTAMP, unit = "day")) %>%
      dplyr:: mutate(
        SI_DISTANCECA = geosphere::distHaversine(cbind(lag(SI_LONG), lag(SI_LATI)), cbind(SI_LONG, SI_LATI)),
        SI_TDIFF = as.numeric(SI_TIMESTAMP - lag(SI_TIMESTAMP), units = "secs"),
        SI_SPCA = (SI_DISTANCECA / SI_TDIFF) * 1.94384
      ) %>%
      dplyr::ungroup() %>%
      dplyr::select(-`floor_date(SI_TIMESTAMP, unit = "day")`)

    coords <- vessel_track_df %>%
      dplyr::select(SI_LONG, SI_LATI) %>%
      sf::st_as_sf(coords = c("SI_LONG", "SI_LATI"), crs = 4326)

    bearings <- geosphere::bearing(sf::st_coordinates(coords)[-nrow(coords), ], sf::st_coordinates(coords)[-1, ])

    vessel_track_df$SI_COG <- c(NA, if_else(bearings < 0, bearings + 360, bearings))

    vessel_track_df <- stats::na.omit(vessel_track_df)

    vessel_track_df <- vessel_track_df %>%
      dplyr::mutate(SU_ISOB = FALSE, FT_REF = NA, SI_OGT = FALSE) %>%
      dplyr::mutate(
        VE_REF = vessel_code,
        VE_REF = as.factor(VE_REF),
        FT_REF = as.factor(FT_REF),
        LE_MET4 = as.factor(ifelse(is.na(le_met4_value), NA, le_met4_value)),
        LE_MET6 = as.factor(ifelse(is.na(le_met6_value), NA, le_met6_value)),
        LE_MET7 = as.factor(ifelse(is.na(le_met7_value), NA, le_met7_value)),
        SI_FSTATUS = as.factor(NA),
        SU_ISOB = as.factor(SU_ISOB),
        SI_OGT = as.factor(SI_OGT),
        SI_FOPER = as.factor(NA)
      )

    vessel_track_df <- vessel_track_df %>%
      dplyr::select(
        VE_REF, FT_REF, SI_TIMESTAMP, SI_LATI, SI_LONG, SI_SP, SI_SPCA, SI_HE,
        SI_COG, SI_DISTANCECA, SI_TDIFF, LE_MET4, LE_MET6, LE_MET7,
        SI_FSTATUS, SI_FOPER, SU_ISOB, SI_OGT
      )

    # Save the final CSV and RDS
    write.table(vessel_track_df,
                file = csv_formateado,
                sep = ";",
                dec = ".",
                row.names = FALSE,
                col.names = TRUE,
                quote = FALSE)

    saveRDS(vessel_track_df, file = rds_formateado)

    vessel_track_df$geometry <- sf::st_as_text(sf::st_as_sf(vessel_track_df, coords = c("SI_LONG", "SI_LATI"), crs = 4326)$geometry)

    write.table(as.data.frame(vessel_track_df),
                file = postgis_csv,
                sep = ";",
                dec = ".",
                row.names = FALSE,
                col.names = TRUE,
                quote = FALSE,
                na = "")

    # Save the final processed data in required formats
    write.table(vessel_track_df,
                file = final_csv,
                sep = ";",
                dec = ".",
                row.names = FALSE,
                col.names = TRUE,
                quote = FALSE,
                na = "")

    saveRDS(vessel_track_df, file = final_rds)

    # Use sf to preserve proper geometries
    vessel_track_sf <- sf::st_as_sf(vessel_track_df, coords = c("SI_LONG", "SI_LATI"), crs = 4326)
    sf::st_write(vessel_track_sf, final_gpkg, append = FALSE)
  }

  # Process files based on the process_all flag
  if (process_all) {
    # List all CSV files in the directory
    files <- list.files(dir, pattern = "\\.csv$", full.names = TRUE)
    for (file_path in files) {
      process_single_file(file_path, vessel_code, le_met4_value, le_met6_value, le_met7_value)
    }
  } else {
    # Process the specified single file
    if (is.null(input_file)) {
      stop("input_file must be provided if process_all is FALSE")
    }
    input_path <- file.path(dir, input_file)
    process_single_file(input_path, vessel_code, le_met4_value, le_met6_value, le_met7_value)
  }
}
